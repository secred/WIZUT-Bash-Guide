\documentclass[10 pt, a4paper]{article}
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{verbatim}
\usepackage{listings}

\usepackage{color}
\usepackage{textcomp}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{
	%backgroundcolor=\color{lbcolor},
	tabsize=4,
	%rulecolor=,
    %basicstyle=\scriptsize,
    upquote=true,
    aboveskip={1.5\baselineskip},
    columns=fixed,
    showstringspaces=false,
    extendedchars=true,
    breaklines=true,
    %frame=single,
    showtabs=false,
    showspaces=false,
    showstringspaces=false,
    identifierstyle=\ttfamily,
    numbers=left, 
    numberstyle=\tiny, 
    stepnumber=1, 
    numbersep=5pt,
}
%TODO: Configure listing.

\author{Krzysztof Czajkowski}
\title{WIZUT Bash Guide - Rozdział III\\
Wyrażenia warunkowe}

\begin{document}
\maketitle
\tableofcontents
\newpage

%TODO: Add intro for chapter, add something about if`s.
\section{Wstęp}
W tym rozdziale dowiemy się o wyrażeniach warunkowych. Wyrażenia warunkowe jako część języka skryptowego bash, pozwalają na wykonywanie przydzielonych instrukcji w zależności od wyboru użytkownika, aplikacji lub sprawdzenia czy zdefiniowane zapytanie będzie prawdą lub fałszem. Możliwość warunkowego decydowania o wykonywanym kroku jest bardzo istotna, zdecydowania większość algorytmów jej wymaga.
\section{if}
\subsection{Wstęp}
Instrukcja warunkowa if jest jedną z najpopularniejszych instrukcji. Bez niej tworzenie aplikacji opartych na wyborach w zależności od sytuacji byłoby bardzo uciążliwe.
\subsection{Składnia}
Podstawowa składnia wygląda następująco:
\begin{lstlisting}
if warunek
then
	polecenie
fi
\end{lstlisting}
Składnie rozpoczyna się od wyrazu \texttt{if}, po słowie \texttt{then} umieszczone są polecenia do wykonania. Instrukcja kończy się słowem \texttt{fi}. Warunek jest wyrażeniem logicznym, instrukcja if sprawdza czy jest ono prawdą. W zależności od tego zostaje wykonywane polecenie lub nie.\newline
A co jeśli potrzebujemy też wydać polecenia w razie negatywnego wyniku? Składnia \texttt{if} posiada polecenie \texttt{else}, po którego umieszczeniu uzyskamy taką możliwość.
\begin{lstlisting}
if warunek
then
	polecenie
else
	polecenie2
fi
\end{lstlisting}
A co jeśli mamy do rozpatrzenia więcej niż jeden warunek? Istnieje polecenie \texttt{elif} pozwalające rozpatrywać kolejne warunki.
\begin{lstlisting}
if warunek
then
	polecenie
elif warunek2
then
	polecenie2
else
	polecenie3
fi
\end{lstlisting}
\subsection{Nawiasy () i []}
W instrukcji if możliwe jest użycie nawiasów okrągłych oraz kwadratowych. Czy różnica między nimi jest znacząca? Oczywiście jest i to bardzo.
\section{case}
\subsection{Wstęp}
%TODO: Change this text
Wyobraźmy sobie sytuację, gdzie mamy za zadanie napisanie prostego menu z kilkoma
opcjami do wyboru, rozwiązanie problemu wyboru opcji na warunku if wydaje się
bezsensowne ze względu na zmuszenie do zapisania dużej ilości if`ów co powoduje brak
czytelności kodu. Rozwiązanie tego problemu za pomocą instrukcji case będzie o wiele
lepszym i czytelniejszym rozwiązaniem.

\subsection{Składnia}
Składnia case`a wygląda następująco:

\lstinputlisting[language=bash]{syntax_case.sh}

Jest ona bardzo prosta do zrozumienia. Pierwsza linijka zaczynająca instrukcję zawiera
wartość zdefiniowaną przez nas w zmiennej, następnie linijki są wzorcami sprawdzającymi
poprawność z wartością, jeśli któraś okaże się zgodna, wtedy następuje wykonanie poleceń
przypisanych do tego wzorca i zakończenie instrukcji. Jeśli żaden ze wzorców nie będzie
pasować, następuje wtedy wykonanie polecenia domyślnego, które oznaczone jest przez * i
zakończenie działania instrukcji. Aby składnia była prawidłowa, należy na końcu listy
wzorców zapisać komendę \texttt{esac}.

\subsection{Przykład} 

\lstinputlisting[language=bash]{example_case.sh}

Proste menu, prosto i czytelnie zapisane. Wpisując liczbę 1, 2 lub 3 trafimy na któryś ze
wzorców i zostaną wykonane przypisane mu polecenia (jak widać we wzorcu 1 i 2, można
zapisać więcej niż jedno polecenie, wystarczy oddzielić je średnikiem). Wpisanie
czegokolwiek innego spowoduje wyświetlenie \texttt{Bledny wybor}.
\newline

\section{select}
%TODO: Add intro.
\subsection{Składnia}

\begin{lstlisting}
select zmienna in lista
do
	polecenie
done
\end{lstlisting}

\subsection{Przykład}

\lstinputlisting[language=bash]{example_select.sh}
Uruchamiając taki skrypt, wyświetlone zostanie pytanie oraz 3 opcje do wyboru: \newline
\begin{verbatim}
[czaja@vaio][~] $ sh example_select.sh
Wybierz katalog ktorego zawartosc chcesz obejrzec:
1) /home
2) /media
3) /mnt
#?
\end{verbatim}
Aby dokonać wyboru wpisujemy odpowiednią cyfrę, zostanie wykonane polecenie (w tym
wypadku \texttt{ls -la}) dla tej zmiennej. Za poleceniem \texttt{ls} znajduje się \texttt{break}, dlaczego? Pętla \texttt{select} jest pętlą wieczną, wyjście z niej możliwe jest tylko poprzez przerwanie jej.
 
\section{Zastosowanie case i select}
Problem przytoczony przy omawianiu instrukcji case, można uprościć dodając instrukcję select. \newline
\lstinputlisting[language=bash]{example_cs.sh}
%TODO: Add comment.
\end{document}